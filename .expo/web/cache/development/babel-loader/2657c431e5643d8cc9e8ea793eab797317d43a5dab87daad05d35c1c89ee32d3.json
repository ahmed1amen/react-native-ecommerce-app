{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createAnimatedComponent;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _react = _interopRequireDefault(require(\"react\"));\nvar _reactNative = require(\"react-native\");\nvar _ReanimatedEventEmitter = _interopRequireDefault(require(\"./ReanimatedEventEmitter\"));\nvar _AnimatedEvent = _interopRequireDefault(require(\"./core/AnimatedEvent\"));\nvar _AnimatedNode = _interopRequireDefault(require(\"./core/AnimatedNode\"));\nvar _AnimatedValue = _interopRequireDefault(require(\"./core/AnimatedValue\"));\nvar _AnimatedProps = require(\"./core/AnimatedProps\");\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar NODE_MAPPING = new Map();\nfunction listener(data) {\n  var component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\nfunction dummyListener() {}\nfunction createAnimatedComponent(Component) {\n  (0, _invariant.default)(typeof Component !== 'function' || Component.prototype && Component.prototype.isReactComponent, '`createAnimatedComponent` does not support stateless functional components; ' + 'use a class component instead.');\n  var AnimatedComponent = function (_React$Component) {\n    (0, _inherits2.default)(AnimatedComponent, _React$Component);\n    var _super = _createSuper(AnimatedComponent);\n    function AnimatedComponent(props) {\n      var _this;\n      (0, _classCallCheck2.default)(this, AnimatedComponent);\n      _this = _super.call(this, props);\n      _defineProperty((0, _assertThisInitialized2.default)(_this), \"_invokeAnimatedPropsCallbackOnMount\", false);\n      _defineProperty((0, _assertThisInitialized2.default)(_this), \"_animatedPropsCallback\", function () {\n        if (_this._component == null) {\n          _this._invokeAnimatedPropsCallbackOnMount = true;\n        } else if (typeof _this._component.setNativeProps !== 'function') {\n          _this.forceUpdate();\n        } else {\n          _this._component.setNativeProps(_this._propsAnimated.__getValue());\n        }\n      });\n      _defineProperty((0, _assertThisInitialized2.default)(_this), \"_setComponentRef\", function (c) {\n        if (c !== _this._component) {\n          _this._component = c;\n        }\n      });\n      _this._attachProps(_this.props);\n      return _this;\n    }\n    (0, _createClass2.default)(AnimatedComponent, [{\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this._detachPropUpdater();\n        this._propsAnimated && this._propsAnimated.__detach();\n        this._detachNativeEvents();\n      }\n    }, {\n      key: \"setNativeProps\",\n      value: function setNativeProps(props) {\n        this._component.setNativeProps(props);\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        if (this._invokeAnimatedPropsCallbackOnMount) {\n          this._invokeAnimatedPropsCallbackOnMount = false;\n          this._animatedPropsCallback();\n        }\n        this._propsAnimated.setNativeView(this._component);\n        this._attachNativeEvents();\n        this._attachPropUpdater();\n      }\n    }, {\n      key: \"_getEventViewRef\",\n      value: function _getEventViewRef() {\n        return this._component.getScrollableNode ? this._component.getScrollableNode() : this._component;\n      }\n    }, {\n      key: \"_attachNativeEvents\",\n      value: function _attachNativeEvents() {\n        var node = this._getEventViewRef();\n        for (var key in this.props) {\n          var prop = this.props[key];\n          if (prop instanceof _AnimatedEvent.default) {\n            prop.attachEvent(node, key);\n          }\n        }\n      }\n    }, {\n      key: \"_detachNativeEvents\",\n      value: function _detachNativeEvents() {\n        var node = this._getEventViewRef();\n        for (var key in this.props) {\n          var prop = this.props[key];\n          if (prop instanceof _AnimatedEvent.default) {\n            prop.detachEvent(node, key);\n          }\n        }\n      }\n    }, {\n      key: \"_reattachNativeEvents\",\n      value: function _reattachNativeEvents(prevProps) {\n        var node = this._getEventViewRef();\n        var attached = new Set();\n        var nextEvts = new Set();\n        for (var key in this.props) {\n          var prop = this.props[key];\n          if (prop instanceof _AnimatedEvent.default) {\n            nextEvts.add(prop.__nodeID);\n          }\n        }\n        for (var _key in prevProps) {\n          var _prop = this.props[_key];\n          if (_prop instanceof _AnimatedEvent.default) {\n            if (!nextEvts.has(_prop.__nodeID)) {\n              _prop.detachEvent(node, _key);\n            } else {\n              attached.add(_prop.__nodeID);\n            }\n          }\n        }\n        for (var _key2 in this.props) {\n          var _prop2 = this.props[_key2];\n          if (_prop2 instanceof _AnimatedEvent.default && !attached.has(_prop2.__nodeID)) {\n            _prop2.attachEvent(node, _key2);\n          }\n        }\n      }\n    }, {\n      key: \"_attachProps\",\n      value: function _attachProps(nextProps) {\n        var oldPropsAnimated = this._propsAnimated;\n        this._propsAnimated = (0, _AnimatedProps.createOrReusePropsNode)(nextProps, this._animatedPropsCallback, oldPropsAnimated);\n        if (oldPropsAnimated !== this._propsAnimated) {\n          oldPropsAnimated && oldPropsAnimated.__detach();\n        }\n      }\n    }, {\n      key: \"_updateFromNative\",\n      value: function _updateFromNative(props) {\n        this._component.setNativeProps(props);\n      }\n    }, {\n      key: \"_attachPropUpdater\",\n      value: function _attachPropUpdater() {\n        var viewTag = (0, _reactNative.findNodeHandle)(this);\n        NODE_MAPPING.set(viewTag, this);\n        if (NODE_MAPPING.size === 1) {\n          _ReanimatedEventEmitter.default.addListener('onReanimatedPropsChange', listener);\n        }\n      }\n    }, {\n      key: \"_detachPropUpdater\",\n      value: function _detachPropUpdater() {\n        var viewTag = (0, _reactNative.findNodeHandle)(this);\n        NODE_MAPPING.delete(viewTag);\n        if (NODE_MAPPING.size === 0) {\n          _ReanimatedEventEmitter.default.removeAllListeners('onReanimatedPropsChange');\n        }\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        this._attachProps(this.props);\n        this._reattachNativeEvents(prevProps);\n        this._propsAnimated.setNativeView(this._component);\n      }\n    }, {\n      key: \"_filterNonAnimatedStyle\",\n      value: function _filterNonAnimatedStyle(inputStyle) {\n        var style = {};\n        for (var key in inputStyle) {\n          var value = inputStyle[key];\n          if (key !== 'transform') {\n            if (value instanceof _AnimatedValue.default) {\n              style[key] = value._startingValue;\n            } else if (!(value instanceof _AnimatedNode.default)) {\n              style[key] = value;\n            }\n          }\n        }\n        return style;\n      }\n    }, {\n      key: \"_filterNonAnimatedProps\",\n      value: function _filterNonAnimatedProps(inputProps) {\n        var props = {};\n        for (var key in inputProps) {\n          var value = inputProps[key];\n          if (key === 'style') {\n            props[key] = this._filterNonAnimatedStyle(_reactNative.StyleSheet.flatten(value));\n          } else if (value instanceof _AnimatedEvent.default) {\n            props[key] = dummyListener;\n          } else if (value instanceof _AnimatedValue.default) {\n            props[key] = value._startingValue;\n          } else if (!(value instanceof _AnimatedNode.default)) {\n            props[key] = value;\n          }\n        }\n        return props;\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var props = this._filterNonAnimatedProps(this.props);\n        var platformProps = _reactNative.Platform.select({\n          web: {},\n          default: {\n            collapsable: false\n          }\n        });\n        return _react.default.createElement(Component, _extends({}, props, {\n          ref: this._setComponentRef\n        }, platformProps));\n      }\n    }, {\n      key: \"getNode\",\n      value: function getNode() {\n        return this._component;\n      }\n    }]);\n    return AnimatedComponent;\n  }(_react.default.Component);\n  AnimatedComponent.displayName = \"AnimatedComponent(\".concat(Component.displayName || Component.name || 'Component', \")\");\n  return AnimatedComponent;\n}","map":{"version":3,"names":["_react","_interopRequireDefault","require","_reactNative","_ReanimatedEventEmitter","_AnimatedEvent","_AnimatedNode","_AnimatedValue","_AnimatedProps","_invariant","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","_getPrototypeOf2","default","result","NewTarget","constructor","Reflect","construct","arguments","apply","_possibleConstructorReturn2","sham","Proxy","Boolean","prototype","valueOf","call","e","NODE_MAPPING","Map","listener","data","component","get","viewTag","_updateFromNative","props","dummyListener","createAnimatedComponent","Component","invariant","isReactComponent","AnimatedComponent","_React$Component","_inherits2","_super","_this","_classCallCheck2","_defineProperty","_assertThisInitialized2","_component","_invokeAnimatedPropsCallbackOnMount","setNativeProps","forceUpdate","_propsAnimated","__getValue","c","_attachProps","_createClass2","key","value","componentWillUnmount","_detachPropUpdater","__detach","_detachNativeEvents","componentDidMount","_animatedPropsCallback","setNativeView","_attachNativeEvents","_attachPropUpdater","_getEventViewRef","getScrollableNode","node","prop","AnimatedEvent","attachEvent","detachEvent","_reattachNativeEvents","prevProps","attached","Set","nextEvts","add","__nodeID","has","nextProps","oldPropsAnimated","createOrReusePropsNode","findNodeHandle","set","size","ReanimatedEventEmitter","addListener","delete","removeAllListeners","componentDidUpdate","_filterNonAnimatedStyle","inputStyle","style","AnimatedValue","_startingValue","AnimatedNode","_filterNonAnimatedProps","inputProps","StyleSheet","flatten","render","platformProps","Platform","select","web","collapsable","React","createElement","_extends","ref","_setComponentRef","getNode","displayName","concat","name"],"sources":["/home/ahmed/Music/softtag/Source Code/node_modules/react-native-reanimated/lib/module/createAnimatedComponent.js"],"sourcesContent":["import React from 'react';\nimport { findNodeHandle, Platform, StyleSheet } from 'react-native';\nimport ReanimatedEventEmitter from './ReanimatedEventEmitter';\n\nimport AnimatedEvent from './core/AnimatedEvent';\nimport AnimatedNode from './core/AnimatedNode';\nimport AnimatedValue from './core/AnimatedValue';\nimport { createOrReusePropsNode } from './core/AnimatedProps';\n\nimport invariant from 'fbjs/lib/invariant';\n\nconst NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  const component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nfunction dummyListener() {\n  // empty listener we use to assign to listener properties for which animated\n  // event is used.\n}\n\nexport default function createAnimatedComponent(Component) {\n  invariant(\n    typeof Component !== 'function' ||\n      (Component.prototype && Component.prototype.isReactComponent),\n    '`createAnimatedComponent` does not support stateless functional components; ' +\n      'use a class component instead.'\n  );\n\n  class AnimatedComponent extends React.Component {\n    _invokeAnimatedPropsCallbackOnMount = false;\n\n    constructor(props) {\n      super(props);\n      this._attachProps(this.props);\n    }\n\n    componentWillUnmount() {\n      this._detachPropUpdater();\n      this._propsAnimated && this._propsAnimated.__detach();\n      this._detachNativeEvents();\n    }\n\n    setNativeProps(props) {\n      this._component.setNativeProps(props);\n    }\n\n    componentDidMount() {\n      if (this._invokeAnimatedPropsCallbackOnMount) {\n        this._invokeAnimatedPropsCallbackOnMount = false;\n        this._animatedPropsCallback();\n      }\n\n      this._propsAnimated.setNativeView(this._component);\n      this._attachNativeEvents();\n      this._attachPropUpdater();\n    }\n\n    _getEventViewRef() {\n      // Make sure to get the scrollable node for components that implement\n      // `ScrollResponder.Mixin`.\n      return this._component.getScrollableNode\n        ? this._component.getScrollableNode()\n        : this._component;\n    }\n\n    _attachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    _detachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.detachEvent(node, key);\n        }\n      }\n    }\n\n    _reattachNativeEvents(prevProps) {\n      const node = this._getEventViewRef();\n      const attached = new Set();\n      const nextEvts = new Set();\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          nextEvts.add(prop.__nodeID);\n        }\n      }\n      for (const key in prevProps) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          if (!nextEvts.has(prop.__nodeID)) {\n            // event was in prev props but not in current props, we detach\n            prop.detachEvent(node, key);\n          } else {\n            // event was in prev and is still in current props\n            attached.add(prop.__nodeID);\n          }\n        }\n      }\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent && !attached.has(prop.__nodeID)) {\n          // not yet attached\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    // The system is best designed when setNativeProps is implemented. It is\n    // able to avoid re-rendering and directly set the attributes that changed.\n    // However, setNativeProps can only be implemented on native components\n    // If you want to animate a composite component, you need to re-render it.\n    // In this case, we have a fallback that uses forceUpdate.\n    _animatedPropsCallback = () => {\n      if (this._component == null) {\n        // AnimatedProps is created in will-mount because it's used in render.\n        // But this callback may be invoked before mount in async mode,\n        // In which case we should defer the setNativeProps() call.\n        // React may throw away uncommitted work in async mode,\n        // So a deferred call won't always be invoked.\n        this._invokeAnimatedPropsCallbackOnMount = true;\n      } else if (typeof this._component.setNativeProps !== 'function') {\n        this.forceUpdate();\n      } else {\n        this._component.setNativeProps(this._propsAnimated.__getValue());\n      }\n    };\n\n    _attachProps(nextProps) {\n      const oldPropsAnimated = this._propsAnimated;\n\n      this._propsAnimated = createOrReusePropsNode(\n        nextProps,\n        this._animatedPropsCallback,\n        oldPropsAnimated\n      );\n      // If prop node has been reused we don't need to call into \"__detach\"\n      if (oldPropsAnimated !== this._propsAnimated) {\n        // When you call detach, it removes the element from the parent list\n        // of children. If it goes to 0, then the parent also detaches itself\n        // and so on.\n        // An optimization is to attach the new elements and THEN detach the old\n        // ones instead of detaching and THEN attaching.\n        // This way the intermediate state isn't to go to 0 and trigger\n        // this expensive recursive detaching to then re-attach everything on\n        // the very next operation.\n        oldPropsAnimated && oldPropsAnimated.__detach();\n      }\n    }\n\n    _updateFromNative(props) {\n      this._component.setNativeProps(props);\n    }\n\n    _attachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.set(viewTag, this);\n      if (NODE_MAPPING.size === 1) {\n        ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n      }\n    }\n\n    _detachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.delete(viewTag);\n      if (NODE_MAPPING.size === 0) {\n        ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n      }\n    }\n\n    componentDidUpdate(prevProps) {\n      this._attachProps(this.props);\n      this._reattachNativeEvents(prevProps);\n\n      this._propsAnimated.setNativeView(this._component);\n    }\n\n    _setComponentRef = c => {\n      if (c !== this._component) {\n        this._component = c;\n      }\n    };\n\n    _filterNonAnimatedStyle(inputStyle) {\n      const style = {};\n      for (const key in inputStyle) {\n        const value = inputStyle[key];\n        if (key !== 'transform') {\n          if (value instanceof AnimatedValue) {\n            style[key] = value._startingValue;\n          } else if (!(value instanceof AnimatedNode)) {\n            style[key] = value;\n          }\n        }\n      }\n      return style;\n    }\n\n    _filterNonAnimatedProps(inputProps) {\n      const props = {};\n      for (const key in inputProps) {\n        const value = inputProps[key];\n        if (key === 'style') {\n          props[key] = this._filterNonAnimatedStyle(StyleSheet.flatten(value));\n        } else if (value instanceof AnimatedEvent) {\n          // we cannot filter out event listeners completely as some components\n          // rely on having a callback registered in order to generate events\n          // alltogether. Therefore we provide a dummy callback here to allow\n          // native event dispatcher to hijack events.\n          props[key] = dummyListener;\n        } else if (value instanceof AnimatedValue) {\n          props[key] = value._startingValue;\n        } else if (!(value instanceof AnimatedNode)) {\n          props[key] = value;\n        }\n      }\n      return props;\n    }\n\n    render() {\n      const props = this._filterNonAnimatedProps(this.props);\n      const platformProps = Platform.select({\n        web: {},\n        default: { collapsable: false },\n      });\n      return (\n        <Component {...props} ref={this._setComponentRef} {...platformProps} />\n      );\n    }\n\n    // A third party library can use getNode()\n    // to get the node reference of the decorated component\n    getNode() {\n      return this._component;\n    }\n  }\n\n  AnimatedComponent.displayName = `AnimatedComponent(${Component.displayName ||\n    Component.name ||\n    'Component'})`;\n\n  return AnimatedComponent;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}