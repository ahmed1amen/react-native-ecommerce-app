{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = backwardsCompatibleAnimWrapper;\nvar _base = require(\"../base\");\nvar _AnimatedClock = _interopRequireDefault(require(\"../core/AnimatedClock\"));\nvar _evaluateOnce = require(\"../derived/evaluateOnce\");\nfunction createOldAnimationObject(node, animationStateDefaults, value, config) {\n  var newClock = new _AnimatedClock.default();\n  var currentState = animationStateDefaults();\n  var alwaysNode;\n  var isStarted = false;\n  var isDone = false;\n  var wasStopped = false;\n  var animationCallback;\n  var animation = {\n    start: function start(currentAnimationCallback) {\n      animationCallback = currentAnimationCallback;\n      if (isStarted) {\n        animationCallback && animationCallback({\n          finished: false\n        });\n        return;\n      }\n      if (isDone) {\n        console.warn('Animation has been finished before');\n        return;\n      }\n      if (!value.isNativelyInitialized()) {\n        return;\n      }\n      isStarted = true;\n      (0, _evaluateOnce.evaluateOnce)((0, _base.set)(currentState.position, value), currentState.position, function () {\n        alwaysNode = (0, _base.always)((0, _base.set)(value, (0, _base.block)([(0, _base.cond)((0, _base.clockRunning)(newClock), 0, (0, _base.startClock)(newClock)), node(newClock, currentState, config), (0, _base.cond)(currentState.finished, [(0, _base.call)([], function () {\n          isStarted = false;\n          if (!wasStopped) {\n            isDone = true;\n          }\n          value.__detachAnimation(animation);\n          isDone = true;\n          if (!wasStopped) {\n            wasStopped = false;\n          }\n        }), (0, _base.stopClock)(newClock)]), currentState.position])));\n        value.__attachAnimation(animation);\n        alwaysNode.__addChild(value);\n      });\n    },\n    __detach: function __detach() {\n      animationCallback && animationCallback({\n        finished: isDone\n      });\n      animationCallback = null;\n      value.__initialized && alwaysNode.__removeChild(value);\n    },\n    stop: function stop() {\n      if (isDone) {\n        console.warn('Calling stop has no effect as the animation has already completed');\n        return;\n      }\n      if (!isStarted) {\n        console.warn(\"Calling stop has no effect as the animation hasn't been started\");\n        return;\n      }\n      wasStopped = true;\n      (0, _evaluateOnce.evaluateOnce)((0, _base.set)(currentState.finished, 1), currentState.finished);\n    },\n    __stopImmediately_testOnly: function __stopImmediately_testOnly(result) {\n      animation.stop();\n      isDone = result;\n      value.__detachAnimation(animation);\n    }\n  };\n  return animation;\n}\nfunction backwardsCompatibleAnimWrapper(node, animationStateDefaults) {\n  return function (clock, state, config) {\n    if (config !== undefined) {\n      return node(clock, state, config);\n    }\n    return createOldAnimationObject(node, animationStateDefaults, clock, state);\n  };\n}","map":{"version":3,"names":["_base","require","_AnimatedClock","_interopRequireDefault","_evaluateOnce","createOldAnimationObject","node","animationStateDefaults","value","config","newClock","Clock","currentState","alwaysNode","isStarted","isDone","wasStopped","animationCallback","animation","start","currentAnimationCallback","finished","console","warn","isNativelyInitialized","evaluateOnce","set","position","always","block","cond","clockRunning","startClock","call","__detachAnimation","stopClock","__attachAnimation","__addChild","__detach","__initialized","__removeChild","stop","__stopImmediately_testOnly","result","backwardsCompatibleAnimWrapper","clock","state","undefined"],"sources":["/home/ahmed/Music/softtag/Source Code/node_modules/react-native-reanimated/lib/module/animations/backwardCompatibleAnimWrapper.js"],"sourcesContent":["import {\n  always,\n  block,\n  call,\n  clockRunning,\n  cond,\n  set,\n  startClock,\n  stopClock,\n} from '../base';\nimport Clock from '../core/AnimatedClock';\nimport { evaluateOnce } from '../derived/evaluateOnce';\n\nfunction createOldAnimationObject(node, animationStateDefaults, value, config) {\n  const newClock = new Clock();\n  const currentState = animationStateDefaults();\n  let alwaysNode;\n  let isStarted = false;\n  let isDone = false;\n  let wasStopped = false;\n  let animationCallback;\n  const animation = {\n    start: currentAnimationCallback => {\n      animationCallback = currentAnimationCallback;\n      if (isStarted) {\n        animationCallback && animationCallback({ finished: false });\n        return;\n      }\n      if (isDone) {\n        console.warn('Animation has been finished before');\n        // inconsistent with React Native\n        return;\n      }\n\n      if (!value.isNativelyInitialized()) {\n        return;\n      }\n\n      isStarted = true;\n      evaluateOnce(\n        set(currentState.position, value),\n        currentState.position,\n        () => {\n          alwaysNode = always(\n            set(\n              value,\n              block([\n                cond(clockRunning(newClock), 0, startClock(newClock)),\n                node(newClock, currentState, config),\n                cond(currentState.finished, [\n                  call([], () => {\n                    isStarted = false;\n                    if (!wasStopped) {\n                      isDone = true;\n                    }\n                    value.__detachAnimation(animation);\n                    isDone = true;\n                    if (!wasStopped) {\n                      wasStopped = false;\n                    }\n                  }),\n                  stopClock(newClock),\n                ]),\n                currentState.position,\n              ])\n            )\n          );\n          value.__attachAnimation(animation);\n          alwaysNode.__addChild(value);\n        }\n      );\n    },\n    __detach: () => {\n      animationCallback && animationCallback({ finished: isDone });\n      animationCallback = null;\n      value.__initialized && alwaysNode.__removeChild(value);\n    },\n    stop: () => {\n      if (isDone) {\n        console.warn(\n          'Calling stop has no effect as the animation has already completed'\n        );\n        return;\n      }\n      if (!isStarted) {\n        console.warn(\n          \"Calling stop has no effect as the animation hasn't been started\"\n        );\n        return;\n      }\n      wasStopped = true;\n      evaluateOnce(set(currentState.finished, 1), currentState.finished);\n    },\n    __stopImmediately_testOnly: result => {\n      animation.stop();\n      isDone = result;\n      value.__detachAnimation(animation);\n    },\n  };\n  return animation;\n}\n\n/**\n * Depending on the arguments list we either return animation node or return an\n * animation object that is compatible with the original Animated API\n */\nexport default function backwardsCompatibleAnimWrapper(\n  node,\n  animationStateDefaults\n) {\n  return (clock, state, config) => {\n    if (config !== undefined) {\n      return node(clock, state, config);\n    }\n    return createOldAnimationObject(node, animationStateDefaults, clock, state);\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}